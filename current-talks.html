---
layout: default
title: Current talks
---

<h1>Current talks</h1>

<i>My talks are always adapted to the audience, and updated until the last minute, so those are just general abstracts. They can be delivered in English or French.</i>


<h2></h2>Building an AI agent with Structured Outputs, Function Calling, and MCP</h2>

<p>
AI agents are programs that can act autonomously: to do this, they must be able to communicate programmatically with an LLM and perform actions.
</p>

<p>In this session, we will explore:
  <ul>
    <li>Structured Outputs: how to require an LLM to respond following a JSON schema, allowing to map the result to Java objects</li>
    <li>Function Calling: how to define and call Java functions from within an AI model</li>
    <li>MCP: the new protocol that standardizes how LLMs communicate with different data sources and tools</li>
  </ul>
</p>
<p>
We will use the code, demos, and documentation I created to implement these features in LangChain4j using OpenAIâ€™s brand-new Java SDK.
</p>

<h2>Easy RAG with LangChain4J and Docker</h2>

<p>
Our goal is to provide you with tools to start experimenting the RAG (retrieval-augmented generation) pattern right away, so you leave this talk with infrastructure and code ready to use for your next AI project.
</p>
<p>
Using the "Easy RAG" project from LangChain4J, we will:
  <ul>
    <li>explain the ideas and concepts behind the RAG pattern</li>
    <li>configure a vector database and an LLM to create a realistic RAG infrastructure inside Docker</li>
    <li>code a simple RAG application in Java</li>
  </ul>
</p>
<p>
Everything will run locally, so you can experiment with the RAG pattern on your laptop.
</p>

<h2>Code generation: how AI will take your job... to the next level!</h2>

<p>
  Code generation has come a long way. From simple scaffolding tools, to complex UML-based modeling tools, the past 2 decades have seen a lot innovation. Then, the AI revolution happened, and everything changed.
</p>
<p>
We'll start this journey by looking at JHipster, a popular code generator that pionneered many code generation techniques over the past decade. We'll see how it evolved, as many companies and Open Source developers have worked together to improve it. We'll see some ideas which worked incredibly well, and some areas where no solution seemed possible until recently.
</p>
<p>
And then, generative AI is changing everything. We'll demo a few cool features from GitHub Copilot:
  <ul>
    <li>generating trivial code instantly</li>
    <li>removing the need to look at the documentation of most APIs</li>
    <li>refactoring your code better than your IDE</li>
  </ul>
</p>

<p>
While this will boost your productivity, and replace some code generation techniques, we'll also see its limits when creating complex applications, using recent tools, or following best practices specific to your company.
</p>
<p>
We'll finish by looking at the future: how AI will evolve in the future to better suit your needs, and how you can mix it with old-school code generation tools to get the best of both worlds.
</p>
